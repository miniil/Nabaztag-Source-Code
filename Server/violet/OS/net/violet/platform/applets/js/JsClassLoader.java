package net.violet.platform.applets.js;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import net.violet.platform.api.exceptions.APIException;
import net.violet.platform.applets.AppResourcesLoader;
import net.violet.platform.applets.js.helpers.JSClassCompiler;
import net.violet.platform.applets.tools.SourceClassLoader;
import net.violet.platform.util.Constantes;

import org.apache.log4j.Logger;
import org.mozilla.javascript.CompilerEnvirons;
import org.mozilla.javascript.Context;
import org.mozilla.javascript.GeneratedClassLoader;
import org.mozilla.javascript.ImporterTopLevel;
import org.mozilla.javascript.JavaScriptException;
import org.mozilla.javascript.Scriptable;
import org.mozilla.javascript.ScriptableObject;
import org.mozilla.javascript.optimizer.ClassCompiler;

/**
 * A ClassLoader that compile JavaScript source into Java classes The
 * ClassLoader can store the compiled classes
 * 
 * @author christophe - Violet
 */
public class JsClassLoader extends ClassLoader implements SourceClassLoader {

	private static final Logger LOGGER = Logger.getLogger(JsClassLoader.class);

	String mApiSource;
	File mCompileDir; // temporary directory to compile the files
	ScriptableObject mScope; // ImporterTopLevel
	Class[] mInterfaces = { Scriptable.class }; // javascript applications will at least implement the Scriptable interface.. -------------------------------------------------------------------------80

	/**
	 * Create a ClassLoader for the provided JavaScript API and implemented
	 * interfaces
	 * 
	 * @param apiSource the source of the application player library (or
	 *            JavaSCript API)
	 * @param additionalInterfaces Rhino Scriptable will be added by default
	 * @throws IOException
	 */
	public JsClassLoader(String apiSource, List<Class> additionalInterfaces) {

		// FIXME: use our own classloader as parent
		super(JsClassLoader.class.getClassLoader());

		this.mCompileDir = new File(Constantes.JS_COMPILED_CLASSES_PATH);
		if (!this.mCompileDir.exists()) {
			this.mCompileDir = null; // FileUtils.forceMkdir(this.mCompileDir);
		}

		this.mApiSource = (apiSource == null) ? net.violet.common.StringShop.EMPTY_STRING : apiSource;

		if (additionalInterfaces != null) {
			final List<Class> interfaces = new ArrayList<Class>(1 + additionalInterfaces.size());
			interfaces.add(Scriptable.class);
			interfaces.addAll(additionalInterfaces);
			this.mInterfaces = interfaces.toArray(this.mInterfaces);
		}

		// create a new global scope level
		final Context cx = Context.enter();
		this.mScope = new ImporterTopLevel(cx);
		Context.exit();
	}

	/**
	 * Find and load a java class implemented in JavaScript.
	 * 
	 * @param appPublicKey (serve as the class name for this application)
	 * @return the class
	 * @throws ClassNotFoundException
	 * @throws JavaScriptException
	 * @see ClassLoader#loadClass(String)
	 */
	@Override
	protected Class<?> findClass(String appPublicKey) throws ClassNotFoundException {

		try {
			final String appSrc = getApplicationSources(appPublicKey);

			if (appSrc == null) {
				throw new ClassNotFoundException("Sources for application " + appPublicKey + " couldn't be found !");
			}

			return loadFromSource(appPublicKey, appSrc);

		} catch (final Exception e) {
			final String strErrMsg = "Unable to load class for JavaScript application " + appPublicKey;
			JsClassLoader.LOGGER.error(strErrMsg, e);
			throw new ClassNotFoundException(strErrMsg, e);

		} finally {
			Context.exit();
		}
	}

	/**
	 * @param inClassName the class name (use the application api_key)
	 * @param inAppSource the JavaScript source of the application (will be
	 *            concatened with the JavaScript API library)
	 * @return aldo la classe
	 */
	public Class loadFromSource(String inClassName, String inAppSource) {

		// init a rhino context
		final Context cx = Context.enter();

		try {
			final CompilerEnvirons compEnv = new CompilerEnvirons();
			compEnv.initFromContext(cx);
			final ClassCompiler compiler = new ClassCompiler(compEnv);

			compiler.setTargetImplements(this.mInterfaces);

			// an array of generated classnames with their bytecodes
			final Object[] byteCodes = compiler.compileToClassFiles(this.mApiSource + inAppSource, inClassName + ".js", 1, inClassName);

			// optionally store the compiled classes
			if (this.mCompileDir != null) {
				try {
					JSClassCompiler.saveClassFiles(byteCodes, this.mCompileDir);
				} catch (final IOException e) {
					JsClassLoader.LOGGER.error("Compiled class files couldn't be saved !", e);
				}
			}

			// define the Java classes from generated byte code
			final GeneratedClassLoader loader = cx.createClassLoader(cx.getApplicationClassLoader());
			Class aldo = null; // the one we must return

			for (int i = 0; i < byteCodes.length; i += 2) {
				final Class classe = loader.defineClass((String) byteCodes[i], (byte[]) byteCodes[i + 1]);
				loader.linkClass(classe);
				if (i == 0) {
					aldo = classe;
				}
			}

			return aldo;

		} finally {
			Context.exit();
		}
	}

	/**
	 * Find the javascript source file for this class name
	 * 
	 * @param appPublicKey the name of the class we're looking for
	 * @return the javascript source file
	 */

	private String getApplicationSources(String appPublicKey) throws APIException {

		final String appSrc = AppResourcesLoader.LOADER.getApplicationSources(appPublicKey);
		return this.mApiSource + appSrc;
	}
}
